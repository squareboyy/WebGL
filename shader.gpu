// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
attribute vec3 tangent;
attribute vec2 texCoord;

uniform mat4 ModelViewProjectionMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 NormalMatrix;
uniform vec3 LightPosition;
uniform mat3 uTextureMatrix; // Матриця трансформації текстур

varying vec3 vPos;
varying vec3 vLightPos;
varying vec2 vTexCoord;
varying mat3 vTBN;

void main() {
    vec4 pos4 = ModelViewMatrix * vec4(vertex, 1.0);
    vPos = pos4.xyz;
    
    // Застосування матриці трансформації до текстурних координат
    // Перетворення відбувається у 2D просторі (u, v)
    vec3 texCoord3 = uTextureMatrix * vec3(texCoord, 1.0);
    vTexCoord = texCoord3.xy;
    
    vLightPos = LightPosition;

    vec3 N = normalize((NormalMatrix * vec4(normal, 0.0)).xyz);
    vec3 T = normalize((NormalMatrix * vec4(tangent, 0.0)).xyz);
    // Gram-Schmidt orthogonalization
    T = normalize(T - N * dot(T, N));
    vec3 B = cross(N, T);
    vTBN = mat3(T, B, N);

    gl_Position = ModelViewProjectionMatrix * vec4(vertex, 1.0);
}`;

// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

uniform sampler2D iTMU0; // Diffuse Texture
uniform sampler2D iTMU1; // Specular Texture
uniform sampler2D iTMU2; // Normal Map
uniform float Shininess;
uniform vec3 AmbientProduct;
uniform vec3 DiffuseProduct;
uniform vec3 SpecularProduct;

// Booleans to toggle textures
uniform bool uUseDiffuse;
uniform bool uUseSpecular;
uniform bool uUseNormal;

varying vec3 vPos;
varying vec3 vLightPos;
varying vec2 vTexCoord;
varying mat3 vTBN;

void main() {
    // 1. Normal Mapping Logic
    vec3 normalMap;
    if (uUseNormal) {
        normalMap = texture2D(iTMU2, vTexCoord).rgb;
    } else {
        // Flat normal (0, 0, 1) in tangent space -> rgb(0.5, 0.5, 1.0)
        normalMap = vec3(0.5, 0.5, 1.0);
    }
    normalMap = normalize(normalMap * 2.0 - 1.0);
    vec3 N = normalize(vTBN * normalMap);

    // 2. Lighting Vectors
    vec3 L = normalize(vLightPos - vPos);
    vec3 E = normalize(-vPos);
    vec3 H = normalize(L + E);

    // 3. Texture Colors
    vec4 texDiffuse = uUseDiffuse ? texture2D(iTMU0, vTexCoord) : vec4(1.0);
    vec4 texSpecular = uUseSpecular ? texture2D(iTMU1, vTexCoord) : vec4(1.0);

    // 4. Phong Model Calculation
    vec3 ambient = AmbientProduct * texDiffuse.rgb;

    float Kd = max(dot(L, N), 0.0);
    vec3 diffuse = Kd * DiffuseProduct * texDiffuse.rgb;

    float Ks = pow(max(dot(N, H), 0.0), Shininess);
    vec3 specular = Ks * SpecularProduct * texSpecular.rgb;

    gl_FragColor = vec4(ambient + diffuse + specular, 1.0);
}`;